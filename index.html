<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Procedural Platformer</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            background-color: white; /* Fallback background color */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh; /* Full viewport height */
            width: 100vw; /* Full viewport width */
            position: relative; /* Needed for absolute positioning of counter and messages */
        }
        canvas {
            display: block; /* Remove extra space below canvas */
            /* Background will be drawn on canvas, no need for CSS background */
            /* border: 1px solid black; */ /* Optional border */
            width: 100%;
            height: 100%;
            cursor: pointer; /* Indicate it's clickable to start */
        }
        #winCounter {
            position: absolute;
            top: 10px;
            left: 10px;
            font-family: 'Press Start 2P', cursive; /* Apply pixelated font */
            font-size: 20px;
            color: white; /* Change text color to white */
            z-index: 10; /* Ensure it's above the canvas */
            /* Add text shadow for better readability on varying backgrounds */
            text-shadow: 2px 2px black;
            /* Initial state for animation */
            transform: scale(1);
        }
         #messageArea {
            position: absolute;
            top: 10px;
            right: 10px;
            font-family: 'Press Start 2P', cursive; /* Apply pixelated font */
            font-size: 20px;
            color: white; /* Change text color to white */
            z-index: 10; /* Ensure it's above the canvas */
             /* Add text shadow for better readability on varying backgrounds */
            text-shadow: 2px 2px black;
            /* Initial state for animation */
            opacity: 0; /* Start hidden */
            transform: scale(1); /* Start at normal size */
        }

        /* Keyframes for scaling and fading animation (for messages) */
        @keyframes scale-and-fade {
            0% {
                opacity: 1;
                transform: scale(1); /* Start at normal size */
            }
            /* Spike up instantly */
            1% {
                 transform: scale(1.2);
            }
            /* Hold spike and maintain full opacity */
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
            /* Ease back down and fade out simultaneously */
            100% {
                opacity: 0; /* Fade out completely */
                transform: scale(1); /* Ease back down to normal size */
            }
        }


         /* Keyframes for scaling only animation (for win counter) */
        @keyframes scale-only {
            0% {
                transform: scale(1); /* Start at normal size */
            }
            1% {
                transform: scale(1.2); /* Instantly spike up */
            }
             50% {
                transform: scale(1.2); /* Hold spike */
            }
            100% {
                transform: scale(1); /* Ease back down */
            }
        }


        /* Class to apply the scale and fade animation */
        .scale-and-fade-message {
            animation: scale-and-fade 0.5s ease-out forwards; /* Changed duration to 0.5s */
        }

         /* Class to apply the scale only animation */
        .scale-only-counter {
            animation: scale-only 0.5s ease-out forwards; /* 0.5s duration */
        }


    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <div id="winCounter">Level: 1</div> <div id="messageArea"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const winCounterElement = document.getElementById('winCounter');
        const messageAreaElement = document.getElementById('messageArea');

        // Set canvas dimensions to fill the screen
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // --- Image Loading ---
        let imagesLoaded = 0;
        const totalImages = 5; // We now need to load 5 images (background, platform, player, finish, spike)

        const backgroundImage = new Image();
        // Corrected background image URL (fixed typo)
        backgroundImage.src = 'https://pixeljoint.com/files/icons/full/sky__r1623380481.png';
        let isBackgroundLoaded = false; // Flag to track if background loaded
        backgroundImage.onload = () => {
             isBackgroundLoaded = true;
             imageLoaded();
        };
        backgroundImage.onerror = () => {
            console.error("Failed to load background image.");
            isBackgroundLoaded = false; // Ensure flag is false on error
            imageLoaded(); // Still count as loaded to potentially start game
        };


        const platformImage = new Image();
        platformImage.src = 'https://opengameart.org/sites/default/files/grass_main_128x128_0.png';
        platformImage.onload = imageLoaded;
        platformImage.onerror = () => {
            console.error("Failed to load platform image.");
            drawPlatforms = drawRectPlatforms; // Fallback
            imageLoaded(); // Still count as loaded to potentially start game
        };

        const playerImage = new Image();
        playerImage.src = 'https://opengameart.org/sites/default/files/Unbenannt_1.png';
        playerImage.onload = imageLoaded;
         playerImage.onerror = () => {
            console.error("Failed to load player image.");
            drawPlayer = drawCirclePlayer; // Fallback
            imageLoaded(); // Still count as loaded to potentially start game
        };

        const finishImage = new Image();
        // Corrected finish image URL
        finishImage.src = 'https://i.ibb.co/gbywcv6R/pixil-frame-0.png';
        finishImage.onload = imageLoaded;
         finishImage.onerror = () => {
            console.error("Failed to load finish image.");
            drawFinish = drawRectFinish; // Fallback
            imageLoaded(); // Still count as loaded to potentially start game
        };

        // Spike image (new)
        const spikeImage = new Image();
        // Using the new direct URL provided by the user
        spikeImage.src = 'https://www.nicepng.com/png/full/228-2287658_pixel-art-maker-spikes-pixel-art.png';
        let isSpikeImageLoaded = false; // Flag to track if spike image loaded
        spikeImage.onload = () => {
            isSpikeImageLoaded = true;
            imageLoaded();
        };
        spikeImage.onerror = () => {
            console.error("Failed to load spike image. Using fallback drawing.");
            isSpikeImageLoaded = false; // Ensure flag is false on error
            imageLoaded(); // Still count as loaded to potentially start game
        };


        function imageLoaded() {
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
                // All images loaded (or errored with fallback), start the game
                generateLevel(); // Create the first level
                gameLoop();      // Start the game loop
                // Removed playSound(winSound) from here
            }
        }
        // --- End Image Loading ---

        // --- Sound Effects (8-bit) ---
        // Using 8-bit sound effects from OpenGameArt.org and Kenney.nl
        const jumpSound = new Audio('https://opengameart.org/sites/default/files/sfx-jump.wav'); // Reverted to OpenGameArt
        jumpSound.volume = 0.3; // Sound effect volume
        const landSound = new Audio('https://opengameart.org/sites/default/files/sfx-land.wav'); // From OpenGameart.org (kept)
        landSound.volume = 0.3; // Sound effect volume
        // Background music (added back)
        const backgroundMusic = new Audio('https://opengameart.org/sites/default/files/8bit%20attempt.ogg'); // Added back
        backgroundMusic.loop = true; // Set to loop
        backgroundMusic.volume = 0.1; // Background music volume (adjusted)
        const loseSound = new Audio('https://opengameart.org/sites/default/files/vgdeathsound.wav'); // Reverted to OpenGameart
        loseSound.volume = 0.3; // Sound effect volume
        // New sound effect for completing a level (using OpenGameart ding as requested)
        // We will create a NEW Audio object for this sound each time it's played for reliability.
        const levelCompleteSoundUrl = 'https://opengameart.org/sites/default/files/sfx_sounds_collect1.wav'; // Store URL


        // Added walking sound effect (will be played repeatedly, not looped by the Audio object)
        const walkSound = new Audio('https://opengameart.org/sites/default/files/sfx-footstep.wav'); // Reverted to OpenGameart
        walkSound.volume = 0.3; // Sound effect volume
        // Removed walkSound.loop = true;

        // Variables for controlling repeated walking sound playback
        let lastFootstepTime = 0; // Timestamp of the last time a footstep sound was played
        const footstepInterval = 250; // Minimum time in milliseconds between footstep sounds (adjust for desired step rate)


        // Function to play a sound effect, resetting it first to allow rapid playback
        // This function will NOT be used for levelCompleteSound anymore.
        function playSound(sound) {
            sound.currentTime = 0; // Rewind to the start
            sound.play().catch(e => {
                // Catch and log errors, likely due to browser autoplay policies
                console.error("Error playing sound:", e);
                if (e.name) console.error("Error name:", e.name);
                if (e.message) console.error("Error message:", e.message);
            });
        }
        // --- End Sound Effects ---

        // --- Background Music Looping Fix ---
        // Add an event listener to explicitly restart the music if it ends while looping is true
        backgroundMusic.addEventListener('ended', () => {
            if (backgroundMusic.loop) {
                backgroundMusic.currentTime = 0; // Optional: rewind to start
                backgroundMusic.play().catch(e => console.error("Error restarting background music loop:", e));
            }
        });
        // --- End Background Music Looping Fix ---


        // Win Counter (resets on page refresh and when losing)
        let winCount = 0; // Initialize to 0 on every page load
        winCounterElement.textContent = 'Level: ' + (winCount + 1); // Changed label and added +1


        // Player properties
        const playerSize = 15; // This now represents the radius for collision/positioning
        // The image will be drawn with dimensions related to playerSize * 2
        let playerX; // Starting X position (will be set after level generation)
        let playerY; // Starting Y position (will be set after level generation)
        const playerSpeed = 5;
        let playerDY = 0; // Delta Y for vertical movement (gravity/jumping)
        const gravity = 0.5;
        let isJumping = false;
        let isFallingThrough = false; // Flag to indicate if player is falling through a platform
        let wasInAir = false; // Flag to track if the player was in the air in the previous frame


        // Key states for continuous movement
        let isLeftKeyPressed = false;
        let isRightKeyPressed = false;

        // Platforms
        const platforms = [];

        // Spikes (re-added and modified generation)
        const spikes = [];
        const spikeSize = 20; // Size for spike drawing and collision
        const spikeProbability = 0.2; // Halved probability of placing a spike in a potential slot


        // Grid properties
        const gridCols = 8; // Number of columns in the grid
        const gridRows = 6;  // Number of rows in the grid
        let gridCellWidth;
        let gridCellHeight;
        const platformHeight = 30; // Fixed height for platforms


        const platformStartProbability = 0.4; // Probability of starting a platform run
        const platformExtendProbability = 0.6; // Probability of extending an existing platform run


        // Finish line properties
        const finishSize = 40; // Increased size for collision and drawing the image
        let finishX;
        let finishY;
        let finishGridCol;
        let finishGridRow;

        let spawnGridCol;
        let spawnGridRow;
        let finishPlatform = null; // Variable to store the chosen finish platform
        let spawnPlatform = null; // Variable to store the chosen spawn platform


        // Flag to pause game logic during delay
        let isGamePausedForDelay = false;


        // Function to display messages temporarily with animation
        function showMessage(message) {
            messageAreaElement.textContent = message;
            // Remove and re-add class to re-trigger animation
            messageAreaElement.classList.remove('scale-and-fade-message');
            // Use requestAnimationFrame to ensure reflow before re-adding class
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    messageAreaElement.classList.add('scale-and-fade-message');
                });
            });

            // Clear the text content after the animation duration (0.5 seconds)
            setTimeout(() => {
                messageAreaElement.textContent = '';
                 messageAreaElement.classList.remove('scale-and-fade-message'); // Clean up class
            }, 500); // Matches animation duration
        }

        // Function to trigger the win counter animation
        function animateWinCounter() {
             // Remove and re-add class to re-trigger animation
             winCounterElement.classList.remove('scale-only-counter');
             requestAnimationFrame(() => {
                 requestAnimationFrame(() => {
                     winCounterElement.classList.add('scale-only-counter');
                 });
             });
             // The class will stay on the element after the animation finishes due to forwards fill-mode,
             // but removing and re-adding it allows the animation to play again.
        }


        // Function to generate random platforms, finish line, and spikes on a grid (connected tiles)
        function generateLevel() {
            // Removed the code that stops and resets the win sound here.
            // The win sound will now continue looping when a new level is generated.

            platforms.length = 0; // Clear existing platforms
            spikes.length = 0; // Clear existing spikes (re-added)
            finishPlatform = null; // Reset finish platform variable
            spawnPlatform = null; // Reset spawn platform variable
            console.log("Generating new level. Platforms and spikes arrays cleared."); // Log level generation start


            // Calculate grid cell dimensions
            gridCellWidth = canvas.width / gridCols;
            gridCellHeight = canvas.height / gridRows;

            // --- 1. Generate Platforms ---
            for (let row = 0; row < gridRows; row++) {
                let currentPlatformX = -1; // Track the start of a potential platform run
                let currentPlatformCol = -1;

                for (let col = 0; col < gridCols; col++) {
                    const cellX = col * gridCellWidth;
                    const cellY = row * gridCellHeight;

                    // If not currently in a platform run, decide if a new one starts
                    if (currentPlatformX === -1) {
                        if (Math.random() < platformStartProbability) {
                            currentPlatformX = cellX;
                            currentPlatformCol = col;
                        }
                    } else {
                        // Currently in a platform run, decide if it extends
                        if (Math.random() < platformExtendProbability) {
                            // Extend the current platform (do nothing, will be added when run ends)
                        } else {
                            // End the current platform run
                            const platformWidth = cellX - currentPlatformX;
                            // Ensure platform has a minimum width of one cell
                            if (platformWidth > 0) {
                                const newPlatform = {
                                    x: currentPlatformX,
                                    y: cellY + gridCellHeight - platformHeight, // Place platform at bottom of cell
                                    width: platformWidth,
                                    height: platformHeight,
                                    gridCol: currentPlatformCol,
                                    gridRow: row // Store grid row of the run
                                };
                                platforms.push(newPlatform);
                            }
                            currentPlatformX = -1; // Reset run tracker
                            currentPlatformCol = -1;
                        }
                    }
                }

                // If a platform run was ongoing at the end of the row, add it
                if (currentPlatformX !== -1) {
                    const platformWidth = canvas.width - currentPlatformX;
                     // Ensure platform has a minimum width
                     if (platformWidth > 0) {
                         const newPlatform = {
                             x: currentPlatformX,
                             y: row * gridCellHeight + gridCellHeight - platformHeight,
                             width: platformWidth,
                             height: platformHeight,
                             gridCol: currentPlatformCol,
                             gridRow: row
                         };
                         platforms.push(newPlatform);
                     }
                }
            }

             // Ensure there's at least one platform
             if (platforms.length === 0) {
                  // Place a default platform if none were generated randomly
                  const defaultCol = 0;
                  const defaultRow = gridRows - 1; // Bottom row
                  const platformWidth = gridCellWidth * 2; // Default is 2 cells wide
                  const platformX = defaultCol * gridCellWidth;
                  const platformY = defaultRow * gridCellHeight + gridCellHeight - platformHeight;
                   platforms.push({
                       x: platformX,
                       y: platformY,
                       width: platformWidth,
                       height: platformHeight,
                       gridCol: defaultCol,
                       gridRow: defaultRow
                   });
             }


            // --- 2. Place Spawn Near Top ---
            const maxSpawnRow = 2; // Consider platforms in rows 0, 1, and 2 for spawning
            const topPlatforms = platforms.filter(platform => platform.gridRow <= maxSpawnRow);

            // Select a random platform from the top platforms, or fallback to any platform if none found at the top
            if (topPlatforms.length > 0) {
                spawnPlatform = topPlatforms[Math.floor(Math.random() * topPlatforms.length)];
                console.log("Spawn placed on a top platform."); // Log placement
            } else {
                // Fallback: select any random platform if no platforms found in the top rows
                console.warn("No platforms found in top rows (0 to " + maxSpawnRow + "). Spawning on a random platform.");
                spawnPlatform = platforms[Math.floor(Math.random() * platforms.length)];
                 // This fallback is safe because we ensure platforms.length > 0 above.
            }

            // Update player position based on selected spawn platform
            playerX = spawnPlatform.x + spawnPlatform.width / 2; // Spawn in the horizontal center of the platform
            playerY = spawnPlatform.y - playerSize; // Spawn just above the platform
            spawnGridCol = spawnPlatform.gridCol; // Store grid column of the platform's start
            spawnGridRow = spawnPlatform.gridRow;
            console.log("Player spawn coordinates:", {playerX, playerY}); // Log final spawn coordinates


            // --- 3. Place Finish Line ---
            do {
                // Select a random platform to place the finish line on
                finishPlatform = platforms[Math.floor(Math.random() * platforms.length)];
                finishGridCol = finishPlatform.gridCol; // Note: This is the starting column of the platform run
                finishGridRow = finishPlatform.gridRow;
            } while (finishPlatform === spawnPlatform); // Ensure finish is not on spawn platform

            // Place finish line at the center of the chosen platform segment
            finishX = finishPlatform.x + finishPlatform.width / 2 - finishSize / 2;
            finishY = finishPlatform.y - finishSize; // Place just above the platform
             console.log("Finish placed at:", {finishX, finishY}); // Log finish coordinates


            // --- 4. Generate Spikes AFTER placing Finish Line and identifying Spawn ---
            // Spikes array was cleared at the beginning of the function
            console.log("Generating spikes after placing finish line and identifying spawn."); // Log spike generation start

            platforms.forEach(platform => {
                // ONLY add spikes if this platform is NOT the finish platform
                if (platform === finishPlatform) {
                    console.log("Skipping spike generation on finish platform."); // Log when skipping finish platform
                    return; // Skip this platform
                }

                // Handle spike generation specifically for the spawn platform
                if (platform === spawnPlatform) {
                    console.log("Generating spikes on spawn platform (max 2, edges only).");
                    let spikesOnSpawn = 0;
                    const numSpikeSlots = Math.floor(platform.width / spikeSize);

                    // Try placing spike on the leftmost slot
                    if (numSpikeSlots > 0 && Math.random() < spikeProbability && spikesOnSpawn < 2) {
                         const spikeSlotX = platform.x; // Leftmost edge
                         const spikeSlotY = platform.y - spikeSize;
                         spikes.push({ x: spikeSlotX, y: spikeSlotY, width: spikeSize, height: spikeSize, gridRow: platform.gridRow });
                         spikesOnSpawn++;
                         // console.log("Spike generated on spawn platform (left).");
                    }

                    // Try placing spike on the rightmost slot (only if there's more than one slot)
                    if (numSpikeSlots > 1 && Math.random() < spikeProbability && spikesOnSpawn < 2) {
                         const spikeSlotX = platform.x + (numSpikeSlots - 1) * spikeSize; // Rightmost edge
                         const spikeSlotY = platform.y - spikeSize;
                         spikes.push({ x: spikeSlotX, y: spikeSlotY, width: spikeSize, height: spikeSize, gridRow: platform.gridRow });
                         spikesOnSpawn++;
                         // console.log("Spike generated on spawn platform (right).");
                    }

                } else {
                    // Handle spike generation for regular platforms (original logic)
                    let consecutiveSpikes = 0;
                    const numSpikeSlots = Math.floor(platform.width / spikeSize); // Number of potential spike positions
                    for (let i = 0; i < numSpikeSlots; i++) {
                        const spikeSlotX = platform.x + i * spikeSize;
                        const spikeSlotY = platform.y - spikeSize; // Place spike just above platform

                        // Decide whether to place a spike in this slot, respecting the consecutive limit
                        let placeSpike = false;
                        if (consecutiveSpikes < 3) {
                            if (Math.random() < spikeProbability) { // Use the updated spikeProbability (0.2)
                                placeSpike = true;
                            }
                        }

                        if (placeSpike) {
                            const newSpike = {
                                x: spikeSlotX,
                                y: spikeSlotY,
                                width: spikeSize,
                                height: spikeSize,
                                gridRow: platform.gridRow // Store grid row of the platform they are on.
                            };
                            spikes.push(newSpike);
                            consecutiveSpikes++;
                            // console.log("Spike generated at:", {x: newSpike.x, y: newSpike.y, gridRow: newSpike.gridRow}); // Keep log for debugging
                        } else {
                            // If no spike was placed, reset the consecutive counter
                            consecutiveSpikes = 0;
                        }
                    }
                }
            });

            console.log("Finished spike generation. Total spikes:", spikes.length); // Log total spikes generated


            // --- 5. Check if Player Spawns on a Spike ---
            // This check is still needed because random placement on edges might still overlap player start depending on size.
            let spawnOnSpike = false;
            spikes.forEach(spike => {
                 // Check for collision between player's initial position and spike
                 // Using a simplified check assuming playerSize is roughly spikeSize / 2 for centering
                 if (playerX > spike.x &&
                     playerX < spike.x + spike.width &&
                     playerY + playerSize > spike.y && // Check bottom of player against top of spike
                     playerY - playerSize < spike.y + spike.height) { // Check top of player against bottom of spike
                     spawnOnSpike = true;
                 }
            });

            if (spawnOnSpike) {
                 console.warn("Player spawned on a spike! Regenerating level."); // Log regeneration
                 generateLevel(); // Regenerate the level if spawn is on a spike
                 return; // Exit this call to generateLevel
            }


            // Reset player vertical velocity and jump state
            playerDY = 0;
            isJumping = false;
            isFallingThrough = false; // Reset fall through flag on new level
            wasInAir = false; // Reset air flag on new level
        }

        // Function to draw platforms as rectangles (fallback)
        function drawRectPlatforms() {
             ctx.fillStyle = 'black';
             platforms.forEach(platform => {
                 ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
             });
        }

        // Function to draw platforms as images
        function drawImagePlatforms() {
             platforms.forEach(platform => {
                 // Draw the image, stretching it to fit the platform dimensions
                 ctx.drawImage(platformImage, platform.x, platform.y, platform.width, platform.height);
             });
        }

        // Initially set to draw images, will fallback if image fails to load
        let drawPlatforms = drawImagePlatforms;

        // Function to draw player as a circle (fallback)
        function drawCirclePlayer() {
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(playerX, playerY, playerSize, 0, Math.PI * 2);
            ctx.fill();
        }

        // Function to draw player as an image
        function drawImagePlayer() {
            // Draw the image centered around the player's (playerX, playerY) coordinates
            // The image is drawn from the top-left corner, so we subtract playerSize
            // The image size is playerSize * 2 by playerSize * 2 to match the circle's diameter
             ctx.drawImage(playerImage, playerX - playerSize, playerY - playerSize, playerSize * 2, playerSize * 2);
        }

        // Initially set to draw image, will fallback if image fails to load
        let drawPlayer = drawImagePlayer;

        // Function to draw finish line as a rectangle (fallback)
        function drawRectFinish() {
            ctx.fillStyle = '#555555'; // Dark grey fallback
            ctx.fillRect(finishX, finishY, finishSize, finishSize);
        }

        // Function to draw finish line as an image
        function drawImageFinish() {
             // Draw the image at the finish line's position and size
             ctx.drawImage(finishImage, finishX, finishY, finishSize, finishSize);
        }

         // Initially set to draw image, will fallback if image fails to load
        let drawFinish = drawImageFinish;

        // Function to draw spikes (image or three pointy spikes fallback)
        function drawSpikes() {
            // console.log("drawSpikes called. Number of spikes:", spikes.length); // Removed frequent log
            if (isSpikeImageLoaded) {
                // Draw spike image
                spikes.forEach(spike => {
                    ctx.drawImage(spikeImage, spike.x, spike.y, spike.width, spike.height);
                });
            } else {
                // Draw three pointy spikes (fallback)
                ctx.fillStyle = 'black'; // Color for spikes
                spikes.forEach(spike => {
                    const sx = spike.x;
                    const sy = spike.y;
                    const sw = spike.width;
                    const sh = spike.height;

                    // Draw three triangles side-by-side
                    ctx.beginPath();
                    ctx.moveTo(sx, sy + sh);
                    ctx.lineTo(sx + sw/6, sy);
                    ctx.lineTo(sx + sw/3, sy + sh);
                    ctx.closePath();
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(sx + sw/3, sy + sh);
                    ctx.lineTo(sx + sw/2, sy);
                    ctx.lineTo(sx + 2*sw/3, sy + sh);
                    ctx.closePath();
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(sx + 2*sw/3, sy + sh);
                    ctx.lineTo(sx + 5*sw/6, sy);
                    ctx.lineTo(sx + sw, sy + sh);
                    ctx.closePath();
                    ctx.fill();
                });
            }
        }


        // Function to draw all game elements
        function draw() {
            // Draw background image or fallback white background
            if (isBackgroundLoaded) {
                 ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            } else {
                 ctx.fillStyle = 'white';
                 ctx.fillRect(0, 0, canvas.width, canvas.height);
            }


            // Draw platforms using the selected method (image or rectangle)
            drawPlatforms();

            // Draw spikes
            drawSpikes();

            // Draw player using the selected method (image or rectangle)
            drawPlayer();

            // Draw finish line using the selected method (image or rectangle)
            drawFinish();
        }

        // Function to update game state
        function update() {
            // Only update game state if the game is not paused for a delay
            if (isGamePausedForDelay) {
                return; // Skip update logic if paused
            }

            // Store if the player was in the air before applying gravity
            wasInAir = isJumping || playerDY !== 0;


            // Apply gravity to player
            playerDY += gravity;
            playerY += playerDY;

            // Apply horizontal movement based on key states
            if (isLeftKeyPressed) {
                playerX -= playerSpeed;
            }
            if (isRightKeyPressed) {
                playerX += playerSpeed;
            }

            // Check for collision with BOTTOM canvas edge - Restart game and reset score if touching
            if (playerY + playerSize > canvas.height) // Bottom edge
             {
                showMessage("Game Over!"); // Changed message
                winCount = 0; // Reset score on loss
                winCounterElement.textContent = 'Level: ' + (winCount + 1); // Changed label
                animateWinCounter(); // Animate win counter on loss
                playSound(loseSound); // Play lose sound

                isLeftKeyPressed = false; // Reset key state
                isRightKeyPressed = false; // Reset key state
                isGamePausedForDelay = true; // Pause game logic
                setTimeout(() => {
                    generateLevel(); // Generate a new level after delay
                    isGamePausedForDelay = false; // Unpause game logic
                }, 1000); // 1 second delay

                return; // Stop updating for this frame
            }

            // Prevent player from going off-screen horizontally and top (without restarting)
            if (playerX - playerSize < 0) playerX = playerSize;
            if (playerX + playerSize > canvas.width) playerX = canvas.width - playerSize;
            if (playerY - playerSize < 0) playerY = playerSize; // Prevent going off top


            // Collision detection with platforms
            let onPlatform = false; // Track if the player is currently on *any* platform
            platforms.forEach(platform => {
                // Check for overlap on both axes
                if (playerX + playerSize > platform.x &&
                    playerX - playerSize < platform.x + platform.width &&
                    playerY + playerSize > platform.y &&
                    playerY - spikeSize < platform.y + platform.height) { // Corrected collision check here

                    // Collision detected. Check if landing on top of the platform AND not trying to fall through
                    if (playerDY > 0 && playerY + playerSize - playerDY <= platform.y && !isFallingThrough) {
                        playerY = platform.y - playerSize; // Place player on top
                        playerDY = 0; // Stop vertical movement
                        isJumping = false; // Player is grounded
                        onPlatform = true; // Player is on this platform

                        // Play land sound if the player was just in the air
                        if (wasInAir) {
                            playSound(landSound);
                        }
                    }
                    // Simple side/bottom collision (optional, can be improved) - Only if not falling through
                    else if (!isFallingThrough) {
                         if (playerDY < 0 && playerY - playerSize + playerDY >= platform.y + platform.height) {
                              // Hit bottom of platform
                              playerY = platform.y + platform.height + playerSize;
                              playerDY = 0;
                         } else if (playerX < platform.x && playerX + playerSize > platform.x) {
                              // Hit left side of platform
                              playerX = platform.x - playerSize;
                         } else if (playerX > platform.x + platform.width && playerX - playerSize < platform.x + platform.width) {
                              // Hit right side of platform
                              playerX = platform.x + platform.width + playerSize;
                         }
                    }
                }
            });

            // If player was falling through and is now not on any platform, reset the flag
            if (isFallingThrough && !onPlatform) {
                 isFallingThrough = false;
            }

            // --- Revised Fix: Update isJumping and wasInAir based on whether the player is on a platform ---
            if (!onPlatform) {
                // If not on a platform, the player is in the air.
                isJumping = true; // Set isJumping to true when airborne
                // wasInAir is already checked at the start of update using isJumping or playerDY
            } else {
                // If on a platform, the player is grounded.
                isJumping = false; // Ensure isJumping is false when grounded
                wasInAir = false; // Ensure wasInAir is false when grounded
            }
            // --- End Revised Fix ---


            // --- Walking Sound Logic (Repeated Playback) ---
            const currentlyWalking = (isLeftKeyPressed || isRightKeyPressed) && !isJumping && playerDY === 0;
            const currentTime = Date.now(); // Get current timestamp

            if (currentlyWalking) {
                // If walking and enough time has passed since the last footstep
                if (currentTime - lastFootstepTime > footstepInterval) {
                    playSound(walkSound); // Play a single footstep sound
                    lastFootstepTime = currentTime; // Update the timestamp
                }
            } else {
                // If not walking, reset the last footstep time to allow a step immediately when walking resumes
                 lastFootstepTime = currentTime; // Set to current time to prevent immediate step on resume
            }
            // Removed the logic that paused/reset the walkSound based on isWalkingSoundPlaying
            // isWalkingSoundPlaying flag is no longer needed for this playback method
            // --- End Walking Sound Logic ---

            // --- Spike Collision Detection --- (re-added)
            spikes.forEach(spike => {
                if (playerX + playerSize > spike.x &&
                    playerX - playerSize < spike.x + spike.width &&
                    playerY + playerSize > spike.y &&
                    playerY - spikeSize < spike.y + spike.height) { // Use spike.y - spikeSize for top collision
                    // Collision with a spike - Player loses
                    showMessage("Hit a spike!"); // Changed message
                    winCount = 0; // Reset score on loss
                    winCounterElement.textContent = 'Level: ' + (winCount + 1); // Changed label
                    animateWinCounter(); // Animate win counter on loss
                    playSound(loseSound); // Play lose sound

                    isLeftKeyPressed = false; // Reset key state
                    isRightKeyPressed = false; // Reset key state
                    isGamePausedForDelay = true; // Pause game logic
                    setTimeout(() => {
                         generateLevel(); // Generate a new level after delay
                         isGamePausedForDelay = false; // Unpause game logic
                    }, 1000); // 1 second delay

                    return; // Stop processing collisions for this frame
                }
            });
            // --- End Spike Collision Detection ---


            // Collision detection with finish line
            if (playerX + playerSize > finishX &&
                playerX - finishSize < finishX + finishSize &&
                playerY + playerSize > finishY &&
                playerY - finishSize < finishY + finishSize) {
                // Player reached the finish line
                console.log("Player reached finish line. Attempting to play level complete sound."); // Added log

                showMessage("Level Complete!"); // Simple win message

                // Increment win counter and update display
                winCount++;
                winCounterElement.textContent = 'Level: ' + (winCount + 1); // Changed label
                animateWinCounter(); // Animate win counter on win

                // Play the level complete sound effect by creating a new instance
                const tempDingSound = new Audio(levelCompleteSoundUrl);
                tempDingSound.volume = 0.3; // Set volume
                tempDingSound.play().catch(e => console.error("Error playing level complete sound:", e));


                // The win sound (background music) continues looping.
                // playSound(winSound); // Removed this call as winSound is background music now.

                isLeftKeyPressed = false; // Reset key state
                isRightKeyPressed = false; // Reset key state
                isGamePausedForDelay = true; // Pause game logic
                setTimeout(() => {
                    generateLevel(); // Generate a new level after delay
                    isGamePausedForDelay = false; // Unpause game logic
                }, 1000); // 1 second delay


                return; // Stop updating for this frame
            }
        }

        // Handle keyboard input - Key Down (press)
        document.addEventListener('keydown', (event) => {
             // Only process input if pointer is locked AND game is not paused
            if (document.pointerLockElement === canvas && !isGamePausedForDelay) {
                switch (event.key) {
                    case 'ArrowLeft':
                        isLeftKeyPressed = true;
                        break;
                    case 'ArrowRight':
                        isRightKeyPressed = true;
                        break;
                    case 'ArrowUp':
                        // Only allow jump if not already jumping and not falling through a platform
                        if (!isJumping && !isFallingThrough) {
                            playerDY = -12; // Jump strength
                            isJumping = true;
                            playSound(jumpSound); // Play jump sound
                        }
                        break;
                    case 'ArrowDown':
                         // Only allow falling through if on a platform and not already falling through
                         if (!isJumping && playerDY === 0) {
                             isFallingThrough = true;
                             // Apply a small downward push to ensure they leave the platform
                             playerDY = 1;
                         }
                         break;
                }
            }
        });

        // Handle keyboard input - Key Up (release)
        document.addEventListener('keyup', (event) => {
             // Only process input if pointer is locked AND game is not paused
            if (document.pointerLockElement === canvas && !isGamePausedForDelay) {
                switch (event.key) {
                    case 'ArrowLeft':
                        isLeftKeyPressed = false;
                        break;
                    case 'ArrowRight':
                        isRightKeyPressed = false;
                        break;
                    case 'ArrowDown':
                         // Reset the falling through flag when the key is released
                         // This prevents getting stuck in fall-through mode
                         isFallingThrough = false;
                         break;
                }
            }
        });

        // Pointer Lock API
        // Reinstated click listener for pointer lock
        canvas.addEventListener('click', () => {
             // Only request pointer lock if the game is not paused for a delay
             if (!isGamePausedForDelay) {
                // Attempt to play and immediately pause all sounds to unlock audio playback
                // This is done to satisfy browser autoplay policies.
                // Removed this as it's now handled on pointerlockchange
                /*
                jumpSound.play().then(() => jumpSound.pause()).catch(e => console.warn("Audio unlock failed for jumpSound:", e));
                landSound.play().then(() => landSound.pause()).catch(e => console.warn("Audio unlock failed for landSound:", e));
                winSound.play().then(() => winSound.pause()).catch(e => console.warn("Audio unlock failed for winSound:", e));
                loseSound.play().then(() => loseSound.pause()).catch(e => console.warn("Audio unlock failed for loseSound:", e));
                */

                canvas.requestPointerLock();
             }
        });

        // Optional: Add listeners for pointer lock change and error
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement !== canvas) {
                // Pointer lock lost, you might want to pause the game or show a message
                 isLeftKeyPressed = false; // Stop movement if lock is lost
                 isRightKeyPressed = false;
                 showMessage("Pointer lock lost. Mouse unlocked."); // Updated message
                 // Pause background music when pointer lock is lost
                 backgroundMusic.pause(); // Pause music
                 // Stop and reset walking sound if pointer lock is lost
                 // isWalkingSoundPlaying flag is no longer used for this logic
                 walkSound.pause();
                 walkSound.currentTime = 0;
                 lastFootstepTime = 0; // Reset timer when lock is lost


            } else {
                 // Pointer lock gained - start background music
                 backgroundMusic.play().catch(e => console.error("Error playing background music:", e)); // Play music
                 lastFootstepTime = Date.now(); // Initialize timer when lock is gained
            }
        });

        document.addEventListener('pointerlockerror', () => {
            console.error("Pointer lock failed");
            showMessage("Pointer lock failed. Game may not respond to input.");
        });


        // Handle window resizing (optional, but good for full screen)
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Note: This doesn't regenerate the level on resize, only adjusts canvas size.
            // For a full regeneration on resize, you'd call generateLevel() here,
            // but that might be jarring.
             showMessage("Window resized. Game canvas updated.");
        });


        // Game loop
        function gameLoop() {
            // Only update game state if pointer is locked and game is not paused
            if (document.pointerLockElement === canvas && !isGamePausedForDelay) {
                update(); // Update game state
            }
            draw();   // Draw everything (always draw even if not updating)
            requestAnimationFrame(gameLoop); // Request the next frame
        }

        // --- Game Initialization ---
        // The game will start automatically once all images have finished loading
        // via the imageLoaded() function.

    </script>

</body>
</html>
