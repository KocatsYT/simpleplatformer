<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Procedural Platformer</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            background-color: white; /* Fallback background color */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh; /* Full viewport height */
            width: 100vw; /* Full viewport width */
            position: relative; /* Needed for absolute positioning of counter and messages */
        }
        canvas {
            display: block; /* Remove extra space below canvas */
            /* Background will be drawn on canvas, no need for CSS background */
            /* border: 1px solid black; */ /* Optional border */
            /* Set width and height to auto to respect the canvas element's intrinsic pixel dimensions */
            width: auto;
            height: auto;
            cursor: pointer; /* Indicate it's clickable to start */
        }
        #winCounter {
            position: absolute;
            top: 10px;
            left: 10px;
            font-family: 'Press Start 2P', cursive; /* Apply pixelated font */
            font-size: 20px;
            color: white; /* Change text color to white */
            z-index: 10; /* Ensure it's above the canvas */
            /* Add text shadow for better readability on varying backgrounds */
            text-shadow: 2px 2px black;
            /* Initial state for animation */
            transform: scale(1);
        }
         #messageArea {
            position: absolute;
            top: 10px;
            right: 10px;
            font-family: 'Press Start 2P', cursive; /* Apply pixelated font */
            font-size: 20px;
            color: white; /* Change text color to white */
            z-index: 10; /* Ensure it's above the canvas */
             /* Add text shadow for better readability on varying backgrounds */
            text-shadow: 2px 2px black;
            /* Initial state for animation */
            opacity: 0; /* Start hidden */
            transform: scale(1); /* Start at normal size */
        }

        /* Keyframes for scaling and fading animation (for messages) */
        @keyframes scale-and-fade {
            0% {
                opacity: 1;
                transform: scale(1); /* Start at normal size */
            }
            /* Spike up instantly */
            1% {
                 transform: scale(1.2);
            }
            /* Hold spike and maintain full opacity */
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
            /* Ease back down and fade out simultaneously */
            100% {
                opacity: 0; /* Fade out completely */
                transform: scale(1); /* Ease back down to normal size */
            }
        }


         /* Keyframes for scaling only animation (for win counter) */
        @keyframes scale-only {
            0% {
                transform: scale(1); /* Start at normal size */
            }
            1% {
                transform: scale(1.2); /* Instantly spike up */
            }
             50% {
                transform: scale(1.2); /* Hold spike */
            }
            100% {
                transform: scale(1); /* Ease back down */
            }
        }


        /* Class to apply the scale and fade animation */
        .scale-and-fade-message {
            animation: scale-and-fade 0.5s ease-out forwards; /* Changed duration to 0.5s */
        }

         /* Class to apply the scale only animation */
        .scale-only-counter {
            animation: scale-only 0.5s ease-out forwards; /* 0.5s duration */
        }


    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <div id="winCounter">Level: 1</div> <div id="messageArea"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const winCounterElement = document.getElementById('winCounter');
        const messageAreaElement = document.getElementById('messageArea');

        // Set canvas dimensions to 125% of the initial window size
        canvas.width = window.innerWidth * 1.25;
        canvas.height = window.innerHeight * 1.25;


        // --- Image Loading ---
        let imagesLoaded = 0;
        const totalImages = 5; // We now need to load 5 images (background, platform, player, finish, spike)

        const backgroundImage = new Image();
        // Corrected background image URL (fixed typo)
        backgroundImage.src = 'https://pixeljoint.com/files/icons/full/sky__r1623380481.png';
        let isBackgroundLoaded = false; // Flag to track if background loaded
        backgroundImage.onload = () => {
             isBackgroundLoaded = true;
             imageLoaded();
        };
        backgroundImage.onerror = () => {
            console.error("Failed to load background image.");
            isBackgroundLoaded = false; // Ensure flag is false on error
            imageLoaded(); // Still count as loaded to potentially start game
        };


        const platformImage = new Image();
        platformImage.src = 'https://opengameart.org/sites/default/files/grass_main_128x128_0.png';
        platformImage.onload = imageLoaded;
        platformImage.onerror = () => {
            console.error("Failed to load platform image.");
            drawPlatforms = drawRectPlatforms; // Fallback
            imageLoaded(); // Still count as loaded to potentially start game
        };

        const playerImage = new Image();
        playerImage.src = 'https://opengameart.org/sites/default/files/Unbenannt_1.png';
        playerImage.onload = imageLoaded;
         playerImage.onerror = () => {
            console.error("Failed to load player image.");
            drawPlayer = drawCirclePlayer; // Fallback
            imageLoaded(); // Still count as loaded to potentially start game
        };

        const finishImage = new Image();
        // Corrected finish image URL
        finishImage.src = 'https://i.ibb.co/gbywcv6R/pixil-frame-0.png';
        finishImage.onload = imageLoaded;
         finishImage.onerror = () => {
            console.error("Failed to load finish image.");
            drawFinish = drawRectFinish; // Fallback
            imageLoaded(); // Still count as loaded to potentially start game
        };

        // Spike image (new)
        const spikeImage = new Image();
        // Using the new direct URL provided by the user
        spikeImage.src = 'https://www.nicepng.com/png/full/228-2287658_pixel-art-maker-spikes-pixel-art.png';
        let isSpikeImageLoaded = false; // Flag to track if spike image loaded
        spikeImage.onload = () => {
            isSpikeImageLoaded = true;
            imageLoaded();
        };
        spikeImage.onerror = () => {
            console.error("Failed to load spike image. Using fallback drawing.");
            isSpikeImageLoaded = false; // Ensure flag is false on error
            imageLoaded(); // Still count as loaded to potentially start game
        };


        function imageLoaded() {
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
                // All images loaded (or errored with fallback), start the game
                generateLevel(); // Create the first level
                gameLoop();      // Start the game loop
                // Removed playSound(winSound) from here
            }
        }
        // --- End Image Loading ---

        // --- Sound Effects (8-bit) ---
        // Using 8-bit sound effects from OpenGameArt.org and Kenney.nl
        const jumpSound = new Audio('https://opengameart.org/sites/default/files/sfx-jump.wav'); // Reverted to OpenGameArt
        jumpSound.volume = 0.3; // Sound effect volume
        const landSound = new Audio('https://opengameart.org/sites/default/files/sfx-land.wav'); // From OpenGameart.org (kept)
        landSound.volume = 0.3; // Sound effect volume
        // Background music (added back)
        const backgroundMusic = new Audio('https://opengameart.org/sites/default/files/8bit%20attempt.ogg'); // Added back
        backgroundMusic.loop = true; // Set to loop
        backgroundMusic.volume = 0.1; // Background music volume (adjusted)
        const loseSound = new Audio('https://opengameart.org/sites/default/files/vgdeathsound.wav'); // Reverted to OpenGameart
        loseSound.volume = 0.3; // Sound effect volume
        // New sound effect for completing a level (using OpenGameart ding as requested)
        // We will create a NEW Audio object for this sound each time it's played for reliability.
        const levelCompleteSoundUrl = 'https://opengameart.org/sites/default/files/sfx_sounds_collect1.wav'; // Store URL


        // Added walking sound effect (will be played repeatedly, not looped by the Audio object)
        const walkSound = new Audio('https://opengameart.org/sites/default/files/sfx-footstep.wav'); // Reverted to OpenGameart
        walkSound.volume = 0.3; // Sound effect volume
        // Removed walkSound.loop = true;

        // Variables for controlling repeated walking sound playback
        let lastFootstepTime = 0; // Timestamp of the last time a footstep sound was played
        const footstepInterval = 250; // Minimum time in milliseconds between footstep sounds (adjust for desired step rate)


        // Function to play a sound effect, resetting it first to allow rapid playback
        // This function will NOT be used for levelCompleteSound anymore.
        function playSound(sound) {
            sound.currentTime = 0; // Rewind to the start
            sound.play().catch(e => {
                // Catch and log errors, likely due to browser autoplay policies
                console.error("Error playing sound:", e);
                if (e.name) console.error("Error name:", e.name);
                if (e.message) console.error("Error message:", e.message);
            });
        }
        // --- End Sound Effects ---

        // --- Background Music Looping Fix ---
        // Add an event listener to explicitly restart the music if it ends while looping is true
        backgroundMusic.addEventListener('ended', () => {
            if (backgroundMusic.loop) {
                backgroundMusic.currentTime = 0; // Optional: rewind to start
                backgroundMusic.play().catch(e => console.error("Error restarting background music loop:", e));
            }
        });
        // --- End Background Music Looping Fix ---


        // Win Counter (resets on page refresh and when losing)
        let winCount = 0; // Initialize to 0 on every page load
        winCounterElement.textContent = 'Level: ' + (winCount + 1); // Changed label and added +1


        // Player properties
        const playerSize = 15; // This now represents the radius for collision/positioning
        // The image will be drawn with dimensions related to playerSize * 2
        let playerX; // Starting X position (will be set after level generation)
        let playerY; // Starting Y position (will be set after level generation)
        const playerSpeed = 5;
        let playerDY = 0; // Delta Y for vertical movement (gravity/jumping)
        const gravity = 0.5;
        let isJumping = false;
        let isFallingThrough = false; // Flag to indicate if player is falling through a platform
        let wasInAir = false; // Flag to track if the player was in the air in the previous frame


        // Key states for continuous movement
        let isLeftKeyPressed = false;
        let isRightKeyPressed = false;

        // Platforms
        const platforms = [];

        // Spikes (re-added and modified generation)
        const spikes = [];
        const spikeSize = 20; // Size for spike drawing and collision
        const spikeProbability = 0.2; // Halved probability of placing a spike in a potential slot


        // Grid properties
        const gridCols = 8; // Number of columns in the grid
        const gridRows = 6;  // Number of rows in the grid
        let gridCellWidth;
        let gridCellHeight;
        const platformHeight = 30; // Fixed height for platforms


        const platformStartProbability = 0.4; // Probability of starting a platform run
        const platformExtendProbability = 0.6; // Probability of extending an existing platform run


        // Finish line properties
        const finishSize = 40; // Increased size for collision and drawing the image
        let finishX;
        let finishY;
        let finishGridCol;
        let finishGridRow;

        let spawnGridCol;
        let spawnGridRow;
        let finishPlatform = null; // Variable to store the chosen finish platform
        let spawnPlatform = null; // Variable to store the chosen spawn platform


        // Flag to pause game logic during delay
        let isGamePausedForDelay = false;


        // Function to display messages temporarily with animation
        function showMessage(message) {
            messageAreaElement.textContent = message;
            // Remove and re-add class to re-trigger animation
            messageAreaElement.classList.remove('scale-and-fade-message');
            // Use requestAnimationFrame to ensure reflow before re-adding class
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    messageAreaElement.classList.add('scale-and-fade-message');
                });
            });

            // Clear the text content after the animation duration (0.5 seconds)
            setTimeout(() => {
                messageAreaElement.textContent = '';
                 messageAreaElement.classList.remove('scale-and-fade-message'); // Clean up class
            }, 500); // Matches animation duration
        }

        // Function to trigger the win counter animation
        function animateWinCounter() {
             // Remove and re-add class to re-trigger animation
             winCounterElement.classList.remove('scale-only-counter');
             requestAnimationFrame(() => {
                 requestAnimationFrame(() => {
                     winCounterElement.classList.add('scale-only-counter');
                 });
             });
             // The class will stay on the element after the animation finishes due to forwards fill-mode,
             // but removing and re-adding it allows the animation to play again.
        }


        // Function to generate random platforms, finish line, and spikes on a grid (connected tiles)
        function generateLevel() {
            // Removed the code that stops and resets the win sound here.
            // The win sound will now continue looping when a new level is generated.

            platforms.length = 0; // Clear existing platforms
            spikes.length = 0; // Clear existing spikes (re-added)
            finishPlatform = null; // Reset finish platform variable
            spawnPlatform = null; // Reset spawn platform variable
            console.log("Generating new level. Platforms and spikes arrays cleared."); // Log level generation start


            // Calculate grid cell dimensions
            gridCellWidth = canvas.width / gridCols;
            gridCellHeight = canvas.height / gridRows;

            // --- 1. Generate Platforms ---
            for (let row = 0; row < gridRows; row++) {
                let currentPlatformX = -1; // Track the start of a potential platform run
                let currentPlatformCol = -1;

                for (let col = 0; col < gridCols; col++) {
                    const cellX = col * gridCellWidth;
                    const cellY = row * gridCellHeight;

                    // If not currently in a platform run, decide if a new one starts
                    if (currentPlatformX === -1) {
                        if (Math.random() < platformStartProbability) {
                            currentPlatformX = cellX;
                            currentPlatformCol = col;
                        }
                    } else {
                        // Currently in a platform run, decide if it extends
                        if (Math.random() < platformExtendProbability) {
                            // Extend the current platform (do nothing, will be added when run ends)
                        } else {
                            // End the current platform run
                            const platformWidth = cellX - currentPlatformX;
                            // Ensure platform has a minimum width of one cell
                            if (platformWidth > 0) {
                                const newPlatform = {
                                    x: currentPlatformX,
                                    y: cellY + gridCellHeight - platformHeight, // Place platform at bottom of cell
                                    width: platformWidth,
                                    height: platformHeight,
                                    gridCol: currentPlatformCol,
                                    gridRow: row // Store grid row of the run
                                };
                                platforms.push(newPlatform);
                            }
                            currentPlatformX = -1; // Reset run tracker
                            currentPlatformCol = -1;
                        }
                    }
                }

                // If a platform run was ongoing at the end of the row, add it
                if (currentPlatformX !== -1) {
                    const platformWidth = canvas.width - currentPlatformX;
                     // Ensure platform has a minimum width
                     if (platformWidth > 0) {
                         const newPlatform = {
                             x: currentPlatformX,
                             y: row * gridCellHeight + gridCellHeight - platformHeight,
                             width: platformWidth,
                             height: platformHeight,
                             gridCol: currentPlatformCol,
                             gridRow: row
                         };
                         platforms.push(newPlatform);
                     }
                }
            }

             // Ensure there's at least one platform
             if (platforms.length === 0) {
                  // Place a default platform if none were generated randomly
                  const defaultCol = 0;
                  const defaultRow = gridRows - 1; // Bottom row
                  const platformWidth = gridCellWidth * 2; // Default is 2 cells wide
                  const platformX = defaultCol * gridCellWidth;
                  const platformY = defaultRow * gridCellHeight + gridCellHeight - platformHeight;
                   platforms.push({
                       x: platformX,
                       y: platformY,
                       width: platformWidth,
                       height: platformHeight,
                       gridCol: defaultCol,
                       gridRow: defaultRow
                   });
             }


            // --- 2. Place Spawn Near Top ---
            const maxSpawnRow = 2; // Consider platforms in rows 0, 1, and 2 for spawning
            const topPlatforms = platforms.filter(platform => platform.gridRow <= maxSpawnRow);

            // Select a random platform from the top platforms, or fallback to any platform if none found at the top
            if (topPlatforms.length > 0) {
                spawnPlatform = topPlatforms[Math.floor(Math.random() * topPlatforms.length)];
                console.log("Spawn placed on a top platform."); // Log placement
            } else {
                // Fallback: select any random platform if no platforms found in the top rows
                console.warn("No platforms found in top rows (0 to " + maxSpawnRow + "). Spawning on a random platform.");
                spawnPlatform = platforms[Math.floor(Math.random() * platforms.length)];
                 // This fallback is safe because we ensure platforms.length > 0 above.
            }

            // Update player position based on selected spawn platform
            playerX = spawnPlatform.x + spawnPlatform.width / 2; // Spawn in the horizontal center of the platform
            playerY = spawnPlatform.y - playerSize; // Spawn just above the platform
            spawnGridCol = spawnPlatform.gridCol; // Store grid column of the platform's start
            spawnGridRow = spawnPlatform.gridRow;
            console.log("Player spawn coordinates:", {playerX, playerY}); // Log final spawn coordinates


            // --- 3. Place Finish Line ---
            do {
                // Select a random platform to place the finish line on
                finishPlatform = platforms[Math.floor(Math.random() * platforms.length)];
                finishGridCol = finishPlatform.gridCol; // Note: This is the starting column of the platform run
                finishGridRow = finishPlatform.gridRow;
            } while (finishPlatform === spawnPlatform); // Ensure finish is not on spawn platform

            // Place finish line at the center of the chosen platform segment
            finishX = finishPlatform.x + finishPlatform.width / 2 - finishSize / 2;
            finishY = finishPlatform.y - finishSize; // Place just above the platform
             console.log("Finish placed at:", {finishX, finishY}); // Log finish coordinates


            // --- 4. Generate Spikes AFTER placing Finish Line and identifying Spawn ---
            // Spikes array was cleared at the beginning of the function
            console.log("Generating spikes after placing finish line and identifying spawn."); // Log spike generation start

            platforms.forEach(platform => {
                // ONLY add spikes if this platform is NOT the finish platform
                if (platform === finishPlatform) {
                    console.log("Skipping spike generation on finish platform."); // Log when skipping finish platform
                    return; // Skip this platform
                }

                // Handle spike generation specifically for the spawn platform
                if (platform === spawnPlatform) {
                    console.log("Generating spikes on spawn platform (max 2, edges only).");
                    let spikesOnSpawn = 0;
                    const numSpikeSlots = Math.floor(platform.width / spikeSize);

                    // Try placing spike on the leftmost slot
                    if (numSpikeSlots > 0 && Math.random() < spikeProbability && spikesOnSpawn < 2) {
                         const spikeSlotX = platform.x; // Leftmost edge
                         const spikeSlotY = platform.y - spikeSize;
                         spikes.push({ x: spikeSlotX, y: spikeSlotY, width: spikeSize, height: spikeSize, grid
